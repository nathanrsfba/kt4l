#!/usr/bin/python3

import json
import random
import sys
from pathlib import Path
import argparse

import mutagen
from mutagen.easyid3 import EasyID3

import selector

# How you know a python coder started out life coding C...
def main():
    # Figure out the root of the 'radio' directory (assumes this script is
    # located in the 'tools' directory of said directory) to work out default
    # paths
    path = Path( __file__ ).absolute().parent.parent

    parser = argparse.ArgumentParser( description='Select the next song to play' )
    parser.add_argument( 
                        '-s', '--state', 
                        default=path / 'configs' / 'state.json',
                        help="Path to file to save state in between calls"
                        )
    parser.add_argument( 
                        '-l', '--library', 
                        default=path / 'library',
                        help="Path to music library"
                        )
    parser.add_argument( 
                        '-u', '--update', 
                        action='store_true',
                        help="Update library without choosing track"
                        )
    parser.add_argument( 
                        '-U', '--update-all', 
                        action='store_true',
                        help="Update library, including unchanged files"
                        )
    args = parser.parse_args()
    if args.update_all: args.update = True

    library = Path( args.library )
    statepath = Path( args.state )

    try:
        with open( statepath ) as fp:
            state = json.load( fp )
    except FileNotFoundError:
        state = {}

    state.setdefault( 'version', 1 )
    state.setdefault( 'time', 0 )
    state.setdefault( 'files', {} )

    removes = {} # Files formerly in library that no longer exist
    adds = {}    # Files just added to library

    # Remove files from the database that no longer exist. But, save a record
    # of them in case they are later found in another folder.
    for file in list( state['files'].keys() ):
        path = library / file
        if not path.exists(): 
            perror( f"Removing {file}" )
            removes[str( path.name )] = state['files'][file]
            del state['files'][file]

    # perror( removes )

    # Load the library
    files = getFiles( library )

    for file in files:
        sfile = str( file )     # Relative path to file, as string
        path = library / file   # Full path to file
        if sfile not in state['files']:
            if str( file.name ) in removes:
                # If a file with the same name was deleted in the same run,
                # consider it 'moved'
                perror( f"Moving {file}" )
                state['files'][sfile] = removes[str( file.name )]
                state['files'][sfile]['folders'] = file.parent.parts
            else:
                perror( f"Adding {file}" )
                id3, easy = mp3Info( path )
                state['files'][sfile] = {
                    'lastplay': None,
                    'added': state['time'],
                    'folders': file.parent.parts,
                    'modified': path.stat().st_mtime,
                    'len': id3.info.length
                    } 
                selector.readTrack( sfile, state, id3, easy )
                    
        elif( 'modified' not in state['files'][sfile] or
             state['files'][sfile]['modified'] < path.stat().st_mtime or
             args.update_all ):
            perror( f"Updating {file}" )
            state['files'][sfile]['modified'] = path.stat().st_mtime
            id3, easy = mp3Info( path )
            state['files'][sfile]['len'] = id3.info.length
            selector.readTrack( sfile, state, id3, easy )


    # perror( json.dumps( state, indent=2 ))

    if not args.update:
        perror( f"Time is {state['time']}" )

        selection = selectTrack( state )

        result = selector.postSelect( selection, state )
        if not result:
            result = (selection,)
        for selection in result:
            state['files'][selection]['lastplay'] = state['time']
            state['time'] += state['files'][selection]['len']
            print( library / selection )

    # Write the state file

    with open( statepath, 'w' ) as fp:
        json.dump( state, fp, indent=2 )

def getFiles( base, sub=Path() ):
    """Recursively get a list of all mp3 files in a directory

    base: The directory to search for files. All paths returned will be
        relative to this directory.
    sub: The subdirectory to search, relative to the base
    """

    base = Path( base )
    current = base
    files = []

    current = current / sub
    files.extend( [sub / x.name for x in current.glob( "*.mp3" )] )
    for dir in [x for x in current.glob( "*/" ) if x.is_dir()]:
        path = sub / dir.name
        files.extend( getFiles( base, path ))

    return files
    
def selectTrack( state ):
    """Select the next track to play.

    Runs through each track in the database, weighing and prioritizing it
    according to the selector module.
    """

    selector.preSelect( state )

    tracks = {}   # List of tracks, grouped by priority
    weights = {}  # Weights of said tracks, in same order and grouping

    for file, info in state['files'].items():
        (pri, weight) = selector.weighTrack( file, state )
        # perror( f"{file}: {pri}.{weight}" )
        tracks.setdefault( pri, [] ).append( file )
        weights.setdefault( pri, [] ).append( weight )

    # Find the highest priority among the listed tracks
    pris = list( tracks.keys() )
    pris.sort()
    toppri = pris[0]

    selection = random.choices( tracks[toppri], weights[toppri] )[0]
    return selection

def mp3Info( f ):
    """Get information on an MP3.

    f: Path to the file

    Return:
    A 2-tuple containing the information as returned by Mutagen, followed by the
    information returned by Mutagen.EasyID3.
    """

    id3 = None
    easy= None

    try:
        id3 = mutagen.File( f )
    except Exception as e:
        perror( e )

    try:
        easy = EasyID3( f )
    except Exception as e:
        perror( e )

    return id3, easy

def perror( *args ):
    """Print information to stderr."""

    print( *args, file=sys.stderr )
    
if __name__ == "__main__":
    # print( mp3Info( 'library/music/misc/X-It.mp3' ))
    main()

